#! /usr/bin/python

# Author: Jesse Millwood

import re
import sys
import getopt
'''
Takes the input from a file and converts it to the machine code
for a simple micro-controller implementation in Verilog on a Xilinx FPGA
Python Version: 2.7
'''
# Instruction   ->  Encoding
#----------------|-------------------
# Load M,R 		-> 000000pr, mmmmmmmm
# STOR R,M 		-> 000001pr, mmmmmmmm
# ADD R 		-> 1000000r 
# SUB R 		-> 1001000r
# LSL R 		-> 1010000r 
# LSR R 		-> 1011000r 
# XOR R 		-> 1100000r
# COM R 		-> 1101000r
# NEG R 		-> 1110000r 
# CLR R 		-> 1111000r
# OUT R,P 		-> 000010ir
# IN P,R 		-> 000011ir
# BCDO R        -> 0100000r
# DEB i,R       -> 001000ir



def readfile(in_path, out_path, type):
	'''
	Reads every line in the file and saves it to a list
	'''
	with open(in_path, 'rb') as filehandle:
		lines = [line.rstrip() for line in filehandle]
	if 'coe' in type:
		if '.' in out_path:
			filetype = out_path[out_path.find('.'):]
			filename = out_path.replace(filetype,'.coe')
		else:
			filename = out_path + '.coe'
	elif 'dat' in type:
		if '.' in out_path:
			filetype = out_path[out_path.find('.')]
			filename = out_path.replace(filetype,'.dat')
		else:
			filename = out_path + '.dat'
	parse(lines, filename, type)

def parse(lines, out_path, type):
	'''
	If the instruction is in the 0 index of the 
	command, parse it and write the appropriate encoding 
	values to a file either specified by the user or the default 
	'''
	# define empty dictionary that will hold 
	# 'desired memory location' : 'desired contents value'
	memory_vals = {}
	# variable to keep track of the line number that the 
	# instructions take up
	lineno = 0

	with open(out_path, 'w') as f:
		if 'coe' in type:
			f.write('; Coefficient file for initializing a 512x8 RAM\n') 
			f.write('; to demonstrate CPU functionality.\n')
			f.write(';\n')
			f.write(';\n')
			f.write('memory_initialization_radix = 2;\n')
			f.write('memory_initialization_vector =\n')

		for line in lines:
			line = line.upper()
			tokens = re.split(',|:|;| ',line)
			if '' in tokens: tokens.remove('')


			if tokens[0].isdigit():
				# Store the initialized memory 
				# value  and contents to be set after the op
				# codes are finished
				memory_vals[tokens[0]] = tokens[1]

			elif 'LOAD' in tokens:
				# convert memory parameter to an integer
				tokens[1] = int(tokens[1])
				# Set bit representing the register
				if 'A' in tokens[2]:
					r = 0
				elif 'B' in tokens[2]:
					r = 1
				# Set bit representing the page and 
				# rewrite memory address with respect to the page
				if tokens[1] <= 255:
					p = 0
				else:
			 		p = 1
			 		tokens[1] = tokens[1]-255
			 	# Put together instructions
			 	instruction1 = '000000'+str(p)+str(r)+'\n'
			 	instruction2 = bin(tokens[1])[2:].zfill(8)+'\n'
			 	# Write to file
				f.write(instruction1)
				f.write(instruction2)
				lineno += 2
			elif 'STOR' in tokens:
				# convert memory parameter to an integer
				tokens[2] = int(tokens[2])
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				# Set bit representing the page
				if tokens[2] <= 255:
					p = 0
				else:
			 		p = 1
			 		tokens[2] = tokens[2] - 255
			 	# Put together instructions
			 	instruction1 = '000000'+str(p)+str(r)+'\n'
			 	instruction2 = bin(tokens[2])[2:].zfill(8)+'\n'
			 	# Write to file
				f.write(instruction1)
				f.write(instruction2)
				lineno+=2
			elif 'ADD' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1000000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'SUB' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1001000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'LSL' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1010000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'LSR' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1011000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'XOR' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1100000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'COM' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1101000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'NEG' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1110000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'CLR' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '1111000'+str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'OUT' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				if tokens[2].isdigit and tokens[2] == 0:
					i = 0
				elif tokens[2].isdigit and tokens[2] == 1:
					i = 1
				instruction1 = '000010'+str(i) + str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'IN' in tokens:
				# Set bit representing the register
				if 'A' in tokens[2]:
					r = 0
				elif 'B' in tokens[2]:
					r = 1
				if tokens[1].isdigit and tokens[1] == 0:
					i = 0
				elif tokens[1].isdigit and tokens[1] == 1:
					i = 1
				instruction1 = '000011'+str(i) + str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'BCDO' in tokens:
				# Set bit representing the register
				if 'A' in tokens[1]:
					r = 0
				elif 'B' in tokens[1]:
					r = 1
				instruction1 = '0100000' + str(r)+'\n'
				f.write(instruction1)
				lineno+=1
			elif 'DEB' in tokens:
				# Set bit representing the register
				if tokens[1].isdigit():
					i = str(tokens[1])
				if 'A' in tokens[2]:
					r = 0
				elif 'B' in tokens[2]:
					r = 1
				instruction1 = '001000' + i + str(r)+'\n'
				f.write(instruction1)
				lineno+=1
		if 'coe' in type:
			f.write(';Instructions:\n')
			for (number,line) in enumerate(lines):
				f.write(';'+str(number)+': '+line+'\n')
			f.write(';--- Memory Starts at line {}\n'.format(lineno))
		for no in range(lineno,512):
			# Start writing the user defined values to the proper
			# memory locations
			if memory_vals.has_key(str(no)):
				binary_rep = bin(int(memory_vals[str(no)]))[2:].zfill(8)
				f.write(binary_rep+'\n')
			else:
				f.write('00000000\n')
		f.write(';')


def main(argv):
	# Default file names options
	inFILE = 'Instructions.dat'
	outFILE= 'Encoding.coe'
	type = 'coe'
	try:
		opts, args = getopt.getopt(argv, 'i:o:ht:',['inFILE','outFILE','help','type'])

	except getopt.GetoptError:
		print 'Nothing you entered was correct... try again bud'
		sys.exit(2)

	for opt, arg in opts:
		if opt in ('-i', '--inFILE'):
			inFILE = arg
		elif opt in ('-o','--outFILE'):
			outFILE = arg
		elif opt in ('-t', '--type'):
			type = arg
		elif opt in ('-h','--help'):
			print 'Simple Assembler Help:'
			print '-t or --type defines the type of output file'
			print 'choices are .coe or .dat'
			print ''
			print '-o or --outFILE defines the name of the output file'
			print '-i or --inFILE defines the name of the input file'

	

	readfile(inFILE, outFILE, type)
	print 'Successful Conversion'






if __name__ == '__main__':
	main(sys.argv[1:])